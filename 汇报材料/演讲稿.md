# 智能股票分析 Agent 演讲稿

## 时长：5分50秒（逻辑顺序版）

---

## 开场（10秒）

大家好！今天我要给大家介绍的是**基于 LangChain 的智能股票分析 Agent**。这是一个能够**自主调用工具、进行多轮推理、输出专业分析报告**的 AI 系统。

接下来我会按照**从整体到局部、从工具到Agent**的逻辑顺序，详细讲解核心代码实现。

---

## 第一部分：系统架构 - 整体流程（40秒）

首先看系统架构和整体流程。

（指向PPT）整个系统分为**三层**：

**第一层是展示层**，我们用 Streamlit 搭建了一个 Web UI。用户可以在这里输入 API 密钥、提出查询问题，界面简洁美观。

**第二层是 Agent 层**，这是核心。它基于 LangChain 框架，负责理解用户意图、决策调用哪些工具、以及整合分析结果。

**第三层是工具层**，我们实现了 5 个股票分析工具，包括历史行情、新闻资讯、技术指标、行业对比和综合分析。所有数据来自 AkShare 这个开源金融数据库。

（指向流程图）整个执行流程是：

**用户查询** → **Streamlit UI** → **Agent 初始化**（绑定工具和提示词）→ **Agent 循环执行**（ReAct模式）→ **工具调用**（获取真实数据）→ **数据返回** → **AI 分析** → **输出报告**。

**核心思想是：Agent 作为"大脑"，工具作为"手脚"，协同完成分析任务。**

---

## 第二部分：工具实现 - Tools的实现与作用（80秒）

接下来看工具是怎么实现的。这是整个系统的基础。

（指向代码）我们看一个完整的例子：**get_stock_history 函数**，获取历史行情。

**第一步，用 @tool 装饰器**。这是 LangChain 的魔法。加上这个装饰器后，函数会自动变成一个"工具对象"。LangChain 会读取函数的文档字符串（docstring），把它转换成工具描述，告诉 LLM："这个工具是干什么的，参数是什么"。

**第二步，调用 AkShare API**。我们使用 `ak.stock_zh_a_hist` 获取 A 股历史数据。参数包括股票代码、周期（日线）、日期范围（最近30天）、复权方式（前复权）。

**第三步，数据清洗**。我们只保留关键字段：日期、开盘、收盘、最高、最低、成交量。然后只取最近 10 天的数据，因为太多数据 LLM 处理起来效率低。

**第四步，返回 Markdown 表格**。调用 `to_markdown()` 方法，把数据转成 Markdown 格式。为什么用 Markdown？因为 LLM 对 Markdown 表格的理解能力很强，比 JSON 或纯文本更好。

**第五步，错误处理**。如果工具执行失败，我们返回错误信息，而不是让程序崩溃。这样 Agent 就能知道工具调用失败了，可以告诉用户。

（指向工具列表）我们实现了 5 个工具：

1. **get_stock_history** - 获取历史行情（30天数据，展示最近10天）
2. **get_stock_news** - 获取最新新闻（最多10条）
3. **get_stock_technical_indicators** - 计算技术指标（MA5、MA10、MA20均线，涨跌幅）
4. **get_industry_comparison** - 行业对比（市值、市盈率、市净率）
5. **analyze_stock_comprehensive** - 综合分析（一键获取所有信息）

**关键点：**
- ✅ **@tool 装饰器**：函数自动变成 LangChain 工具对象
- ✅ **docstring 文档**：LangChain 自动读取，生成工具描述给 LLM
- ✅ **返回格式**：Markdown 表格，LLM 理解能力最强
- ✅ **错误处理**：工具失败时返回错误信息，不崩溃

就这么简单！**一个函数 + 一个装饰器 = 一个 Agent 工具**。

---

## 第三部分：Agent搭建 - 如何初始化（70秒）

有了工具，接下来看 Agent 是怎么搭建的。

（指向代码）这是 **StockAnalysisAgent 类**的完整初始化过程。

**第一步，初始化 LLM**。我们使用 ChatOpenAI，它兼容 OpenAI 的接口，所以可以使用 DeepSeek、Qwen 等国产模型。temperature 参数设为 0.7，控制创造性，既要有分析能力，又不能太天马行空。

**第二步，准备工具**。我们把刚才定义的 5 个工具函数放进一个列表。同时创建一个 tool_map 字典，方便后续根据工具名称快速查找。

**第三步，关键操作：bind_tools**。这一步把工具绑定到 LLM 上。绑定之后，LLM 就知道了："哦，我现在有这些工具可以用了，它们分别能做什么。"LangChain 会自动生成工具调用的格式，LLM 在需要时会自动调用。

**第四步，构建 Prompt**。我们用 ChatPromptTemplate 定义了系统提示词和消息占位符。系统提示词里详细描述了 Agent 应该如何思考、如何选择工具、如何输出分析。MessagesPlaceholder 用来存放历史对话和工具返回的结果。

**第五步，创建 Agent Runnable**。我们用管道操作符 `|` 把 Prompt 和 LLM 连接起来，形成一个可执行的 Agent。这样我们就可以用 `agent_runnable.invoke()` 来运行 Agent 了。

**关键点：**
- ✅ **bind_tools**：让 LLM 知道有哪些工具可用，自动生成工具调用格式
- ✅ **Prompt 工程**：系统提示词引导 AI 按专业步骤思考
- ✅ **Runnable 链**：`prompt | llm_with_tools` 形成可执行的 Agent

这就是 Agent 的搭建过程。核心思想是：**让 LLM 不仅会聊天，还会主动使用工具获取真实数据**。

---

## 第四部分：Agent运行 - 使用Tools和提示词（90秒）

有了搭建好的 Agent，接下来看它怎么运行。

（指向代码）这是 **_run_loop 方法**，它是一个递归函数，实现了 **ReAct 模式**。

ReAct 是什么？就是 **Reasoning（推理） → Action（行动） → Observation（观察）** 的循环。

具体来说：

**第一步，检查最大迭代次数**。我们设置最多 10 轮，防止无限循环。如果超过次数，返回提示信息。

**第二步，调用 LLM**。我们把用户问题和历史消息传给 Agent Runnable，让它思考。LLM 会分析当前情况，决定下一步做什么。

**第三步，检查 tool_calls**。LLM 返回的结果里，如果有 tool_calls 字段，说明它想调用工具。如果没有，说明它已经得出结论了，直接返回文本。

**第四步，执行工具调用**。如果 LLM 想调用工具，我们遍历所有 tool_calls，找到对应的工具函数，传入参数，执行，得到结果。我们把结果包装成 ToolMessage，这是 LangChain 的消息类型，包含了工具调用的 ID，这样 LLM 就知道这个结果对应哪个工具调用。

**第五步，错误处理**。如果工具执行失败，我们返回错误信息，而不是让程序崩溃。这样 Agent 就能知道工具调用失败了。

**第六步，更新消息历史**。我们把 LLM 的输出和工具的结果都添加到消息历史里。这样 LLM 在下一轮就能看到所有历史对话和工具返回的数据。

**第七步，递归调用**。我们带着更新后的消息历史，再次调用 `_run_loop`。这样 LLM 就能看到工具返回的数据，基于数据做进一步分析。

这个过程会循环多次，直到 LLM 不再调用工具，而是给出最终答案。

（指向流程示例）举个例子：

用户查询："分析贵州茅台（600519）的走势"

**第1轮：** LLM 分析后决定调用 `get_stock_history("600519")`，我们执行工具，获取价格数据表格。

**第2轮：** LLM 看到价格数据后，决定调用 `get_stock_technical_indicators("600519")`，我们执行工具，获取技术指标（MA5、MA10、MA20）。

**第3轮：** LLM 看到价格数据和技术指标后，进行综合分析，不再调用工具，直接输出专业报告。

**关键点：**
- ✅ **ReAct 模式**：Reasoning（推理） → Action（行动） → Observation（观察）
- ✅ **递归实现**：每轮逻辑完全一致，代码简洁优雅
- ✅ **消息历史**：LLM 能看到所有历史对话和工具结果
- ✅ **自主决策**：AI 自己决定调用哪些工具、调用几次、何时停止

**这就是 Agent 的"大脑"：它会自己决定调用哪些工具、调用几次、什么时候停下来。**

---

## 第五部分：前端展示 - Streamlit UI（40秒）

最后简单看一下前端界面。

（指向代码）我们用 Streamlit 搭建了一个简洁的 Web UI。

**侧边栏部分**：用户可以输入 API 密钥、API 地址和模型名称。这样用户可以使用自己的 API，不需要我们配置。

**主界面部分**：用户输入查询问题，点击"开始分析"按钮。

**执行过程**：我们初始化 Agent，传入用户配置的 API 信息。然后用 `st.spinner` 显示加载动画，执行查询。

**结果显示**：我们显示分析结果，并展示用了多少步完成分析。这样用户可以看到 Agent 的思考过程。

**UI 特点：**
- ✅ **简洁美观**：现代化设计，响应式布局
- ✅ **API 配置**：用户可自行输入 API 密钥
- ✅ **实时反馈**：显示分析进度和步骤数
- ✅ **历史记录**：保存查询历史，方便回顾

**部署方式：** Streamlit Cloud 一键部署，获得永久访问链接，支持公开分享。

---

## 结尾（20秒）

最后总结：

这个项目的**核心创新点**有四个：

1. **自主决策** - Agent 能自己选择调用哪些工具
2. **多轮推理** - 支持复杂查询的分步分析
3. **专业输出** - 通过提示词工程引导专业分析
4. **易于部署** - Streamlit Cloud 一键部署，任何人都能访问

**技术栈：** LangChain（Agent 框架）、AkShare（数据源）、Streamlit（Web UI）

整个项目大约 **700 行代码**，实现了 **5 个专业工具、完整的 Agent 系统、以及美观的 Web UI**。

---

**我的汇报到此结束，谢谢大家！**

（如果有时间）**欢迎提问。**

---

## 备用问答

### Q1: 为什么选择 LangChain？

**答**：LangChain 提供了成熟的 Agent 框架，包括工具绑定、消息管理、Prompt 模板等功能。如果从零实现，要处理很多细节。用 LangChain 让我们能专注于业务逻辑，而不是底层框架。

### Q2: 数据的准确性如何保证？

**答**：我们使用的 AkShare 是一个开源金融数据库，它的数据来自东方财富、新浪财经等权威平台。AkShare 有上万 Star，社区活跃，数据质量有保障。另外，我们在系统提示词里强制 Agent 必须使用工具获取数据，不能编造，这进一步保证了准确性。

### Q3: 能不能分析美股或港股？

**答**：当前版本仅支持 A 股，因为 AkShare 主要聚焦中国市场。但架构上是可扩展的。如果要支持美股，可以增加新的工具，调用 yfinance 或 Alpha Vantage 等 API。只需要写一个新函数，加个 `@tool` 装饰器，Agent 就能自动学会使用它。

### Q4: 为什么用递归实现 Agent 循环？

**答**：递归实现简洁优雅，每一轮调用的逻辑完全一样：调用 LLM → 检查工具调用 → 执行工具 → 递归。相比用 while 循环，代码更易读。当然，也可以改成迭代方式，看个人习惯。

### Q5: 性能如何？能不能处理高并发？

**答**：单次查询大约 10-30 秒，主要时间花在 LLM 推理上。目前是同步执行，如果要支持高并发，可以用 FastAPI + 异步调用，或者部署多个实例做负载均衡。Streamlit Cloud 免费版资源有限（1GB RAM），如果流量大，建议升级或自己部署。

---

**再次感谢大家！**
